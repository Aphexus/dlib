/*
Copyright (c) 2014-2015 Timur Gafarov 

Boost Software License - Version 1.0 - August 17th, 2003

Permission is hereby granted, free of charge, to any person or organization
obtaining a copy of the software and accompanying documentation covered by
this license (the "Software") to use, reproduce, display, distribute,
execute, and transmit the Software, and to prepare derivative works of the
Software, and to permit third-parties to whom the Software is furnished to
do so, all subject to the following:

The copyright notices in the Software and this entire statement, including
the above license grant, this restriction and the following disclaimer,
must be included in all copies of the Software, in whole or in part, and
all derivative works of the Software, unless such copies or derivative
works are solely in the form of machine-executable object code generated by
a source language processor.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE.
*/

module dlib.image.io.bmp;

private
{
    import std.stdio;
    import dlib.core.stream;
    import dlib.core.memory;
    import dlib.core.compound;
    import dlib.image.image;
    import dlib.image.color;
    import dlib.image.io.io;
    import dlib.image.io.utils;
    import dlib.filesystem.local;
}

// uncomment this to see debug messages:
//version = BMPDebug;

static const ubyte[2] BMPMagic = ['B', 'M'];

struct BMPFileHeader
{
    ubyte[2] type;        // magic number "BM"
    uint size;            // file size
    ushort reserved1; 
    ushort reserved2;
    uint offset;          // offset to image data
}

struct BMPInfoHeader
{
    uint size;            // size of bitmap info header
    int width;            // image width
    int height;           // image height
    ushort planes;        // must be equal to 1
    ushort bitsPerPixel;  // bits per pixel
    uint compression;     // compression type
    uint imageSize;       // size of pixel data
    int xPixelsPerMeter;  // pixels per meter on x-axis
    int yPixelsPerMeter;  // pixels per meter on y-axis
    uint colorsUsed;      // number of used colors
    uint colorsImportant; // number of important colors
}

struct BMPCoreHeader
{
    uint size;            // size of bitmap core header
    ushort width;         // image with
    ushort height;        // image height
    ushort planes;        // must be equal to 1
    ushort bitsPerPixel;  // bits per pixel
}

struct BMPCoreInfo
{
    BMPCoreHeader header;
    ubyte[3] colors;
}

enum BMPOSType
{
    Win,
    OS2
}

// BMP compression type constants
enum BMPCompressionType
{
    RGB          = 0,
    RLE8         = 1,
    RLE4         = 2,
    BitFields    = 3
}

// RLE byte type constants
enum RLE
{
    Command      = 0,
    EndOfLine    = 0,
    EndOfBitmap  = 1,
    Delta        = 2
}

enum BMPInfoSize
{
    OLD  = 12,
    WIN  = 40,
    OS2  = 64,
    WIN4 = 108,
    WIN5 = 124,
}

class BMPLoadException: ImageLoadException
{
    this(string msg, string file = __FILE__, size_t line = __LINE__, Throwable next = null)
    {
        super(msg, file, line, next);
    }
}

private ubyte calculateShift(uint mask) nothrow pure
{
    ubyte result = 0;
    while (mask && !(mask & 1)) {
        result++;
        mask >>= 1;
    }
    return result;
}

private ubyte applyMask(uint value, uint mask, ubyte shift, ubyte scale) nothrow pure
{
    return cast(ubyte) (((value & mask) >> shift) * scale);
}

private ubyte calculateScale(uint mask, ubyte shift) nothrow pure
{
    return cast(ubyte) (256 / calculateDivisor(mask, shift));
}

private uint calculateDivisor(uint mask, ubyte shift) nothrow pure
{
    return (mask >> shift) + 1;
}

private bool checkIndex(uint index, ubyte[] colormap) nothrow pure {
    return index + 2 < colormap.length;
}

/*
 * Load BMP from file using local FileSystem.
 * Causes GC allocation
 */
SuperImage loadBMP(string filename)
{
    InputStream input = openForInput(filename);
    
    try
    {
        return loadBMP(input);
    }
    catch (BMPLoadException ex)
    {
        throw new Exception("'" ~ filename ~ "' :" ~ ex.msg, ex.file, ex.line, ex.next);
    }
    finally
    {
        input.close();
    }
}

/*
 * Load BMP from stream using default image factory.
 * Causes GC allocation
 */
SuperImage loadBMP(InputStream istrm)
{
    Compound!(SuperImage, string) res = 
        loadBMP(istrm, defaultImageFactory);
    if (res[0] is null)
        throw new BMPLoadException(res[1]);
    else
        return res[0];
}

/*
 * Load BMP from stream using specified image factory.
 * GC-free
 */
Compound!(SuperImage, string) loadBMP(
    InputStream istrm, 
    SuperImageFactory imgFac)
{
    SuperImage img = null;

    BMPFileHeader bmpfh;
    BMPInfoHeader bmpih;
    BMPCoreHeader bmpch;

    BMPOSType osType;

    uint compression;
    uint bitsPerPixel;
    
    uint redMask, greenMask, blueMask, alphaMask;

    ubyte[] colormap;
    int colormapSize;

    Compound!(SuperImage, string) error(string errorMsg)
    {
        if (img)
        {
            img.free();
            img = null;
        }
        if (colormap.length)
            Delete(colormap);
        return compound(img, errorMsg);
    }

    bmpfh = readStruct!BMPFileHeader(istrm);

    auto bmphPos = istrm.position;

    version(BMPDebug)
    { 
        writefln("bmpfh.type = %s", cast(char[])bmpfh.type);
        writefln("bmpfh.size = %s", bmpfh.size);
        writefln("bmpfh.reserved1 = %s", bmpfh.reserved1);
        writefln("bmpfh.reserved2 = %s", bmpfh.reserved2);
        writefln("bmpfh.offset = %s", bmpfh.offset);
        writeln("-------------------"); 
    }

    if (bmpfh.type != BMPMagic)
        return error("loadBMP error: input data is not BMP");

    uint numChannels = 3;
    uint width, height;

    bmpih = readStruct!BMPInfoHeader(istrm);

    version(BMPDebug)
    { 
        writefln("bmpih.size = %s", bmpih.size);
        writefln("bmpih.width = %s", bmpih.width);
        writefln("bmpih.height = %s", bmpih.height);
        writefln("bmpih.planes = %s", bmpih.planes);
        writefln("bmpih.bitsPerPixel = %s", bmpih.bitsPerPixel);
        writefln("bmpih.compression = %s", bmpih.compression);
        writefln("bmpih.imageSize = %s", bmpih.imageSize);
        writefln("bmpih.xPixelsPerMeter = %s", bmpih.xPixelsPerMeter);
        writefln("bmpih.yPixelsPerMeter = %s", bmpih.yPixelsPerMeter);
        writefln("bmpih.colorsUsed = %s", bmpih.colorsUsed);
        writefln("bmpih.colorsImportant = %s", bmpih.colorsImportant);
        writeln("-------------------"); 
    }

    if (bmpih.compression > 3)
    {
        /* 
         * This is an OS/2 bitmap file, we don't use
         * bitmap info header but bitmap core header instead
         */

        // We must go back to read bitmap core header
        istrm.position = bmphPos;
        bmpch = readStruct!BMPCoreHeader(istrm);

        osType = BMPOSType.OS2;
        compression = BMPCompressionType.RGB;
        bitsPerPixel = bmpch.bitsPerPixel;

        width = bmpch.width;
        height = bmpch.height;
    }
    else
    {
        // Windows style
        osType = BMPOSType.Win;
        compression = bmpih.compression;
        bitsPerPixel = bmpih.bitsPerPixel;

        width = bmpih.width;
        height = bmpih.height;
    }

    version(BMPDebug)
    { 
        writefln("osType = %s", [BMPOSType.OS2: "OS/2", BMPOSType.Win: "Windows"][osType]);
        writefln("width = %s", width);
        writefln("height = %s", height);
        writefln("bitsPerPixel = %s", bitsPerPixel);
        writefln("compression = %s", compression);
        writeln("-------------------"); 
    }
    
    if (bmpih.size >= BMPInfoSize.WIN4 || (compression == BMPCompressionType.BitFields && (bitsPerPixel == 16 || bitsPerPixel == 32))) {
        bool ok = true;
        ok = ok && istrm.readLE(&redMask);
        ok = ok && istrm.readLE(&greenMask);
        ok = ok && istrm.readLE(&blueMask);
        
        version(BMPDebug) {
            writeln("File has bitfields masks");
            writefln("redMask = %s", redMask);
            writefln("greenMask = %s", greenMask);
            writefln("blueMask = %s", blueMask);
            writeln("-------------------");
        }
        
        if (ok && bmpih.size >= BMPInfoSize.WIN4) {
            version(BMPDebug) {
                writeln("File is at least version 4");
            }
            
            int CSType;
            int[9] coords;
            int gammaRed;
            int gammaGreen;
            int gammaBlue;
            
            ok = ok && istrm.readLE(&alphaMask);
            ok = ok && istrm.readLE(&CSType);
            istrm.fillArray(coords);
            ok = ok && istrm.readLE(&gammaRed);
            ok = ok && istrm.readLE(&gammaGreen);
            ok = ok && istrm.readLE(&gammaBlue);
            
            if (ok && bmpih.size >= BMPInfoSize.WIN5) {
                version(BMPDebug) {
                    writeln("File is at least version 5");
                }
                
                int intent;
                int profileData;
                int profileSize;
                int reserved;
                
                ok = ok && istrm.readLE(&intent);
                ok = ok && istrm.readLE(&profileData);
                ok = ok && istrm.readLE(&profileSize);
                ok = ok && istrm.readLE(&reserved);
            }
        }
        if (!ok) {
            return error("loadBMP error: failed to read data of size specified in bmp info structure");
        }
    }
    
    if (compression != BMPCompressionType.RGB && compression != BMPCompressionType.BitFields && compression != BMPCompressionType.RLE8) {
        return error("loadBMP error: unsupported compression type (RLE4 is not supported yet)");
    }
    
    if (bitsPerPixel != 4 && bitsPerPixel != 8 && bitsPerPixel != 16 && bitsPerPixel != 24 && bitsPerPixel != 32) {
        return error("loadBMP error: unsupported color depth");
    }

    uint numberOfColors;
    ubyte colormapEntrySize = (osType == BMPOSType.OS2)? 3 : 4;
    
    ubyte blueShift, greenShift, redShift, alphaShift;
    ubyte blueScale = 1, greenScale = 1, redScale = 1, alphaScale;
    
    if (bitsPerPixel == 8 || bitsPerPixel == 4)
    {
        numberOfColors = bmpih.colorsUsed ? bmpih.colorsUsed : (1 << bitsPerPixel);
        if (numberOfColors == 0 || numberOfColors > 256) {
            return error("loadBMP error: strange number of used colors");
        }
    } else if (compression == BMPCompressionType.BitFields && (bitsPerPixel == 16 || bitsPerPixel == 32)) {
        redShift = calculateShift(redMask);
        greenShift = calculateShift(greenMask);
        blueShift = calculateShift(blueMask);
        alphaShift = calculateShift(alphaMask);
        
        //scales are used to get equivalent weights for every color channel fit in byte
        
        if (calculateDivisor(redMask, redShift) == 0 || calculateDivisor(greenMask, greenShift) == 0
            || calculateDivisor(blueMask, blueShift) == 0 || calculateDivisor(alphaMask, alphaShift) == 0
        ) {
            return error("loadBMP error: division by zero when calculating scale");
        }
        
        redScale = calculateScale(redMask, redShift);
        greenScale = calculateScale(greenMask, greenShift);
        blueScale = calculateScale(blueMask, blueShift);
        alphaScale = calculateScale(alphaMask, alphaShift);
    } else if (compression == BMPCompressionType.RGB && (bitsPerPixel == 24 || bitsPerPixel == 32)) {
        blueMask = 0x000000ff;
        greenMask = 0x0000ff00;
        redMask = 0x00ff0000;
        blueShift = 0;
        greenShift = 8;
        redShift = 16;
    } else if (compression == BMPCompressionType.RGB && bitsPerPixel == 16) {
        blueMask = 0x001f;
        greenMask = 0x03e0;
        redMask = 0x7c00;
        blueShift = 0;
        greenShift = 2;
        redShift = 7;
        
        blueScale = 8;
    } else {
        return error("loadBMP error: unknown compression type / color depth combination");
    }
    
    // Look for palette data if present
    if (numberOfColors) {
        colormapSize = numberOfColors * colormapEntrySize;
        colormap = New!(ubyte[])(colormapSize);
        istrm.fillArray(colormap);
    }

    // Go to begining of pixel data
    istrm.position = bmpfh.offset;
    
    const bool transparent = alphaMask != 0 && compression == BMPCompressionType.BitFields;
    
    // Create image
    img = imgFac.createImage(width, height, transparent ? 4 : 3, 8);
    
    enum wrongIndexError = "wrong index for colormap";
    
    if (bitsPerPixel == 4 && compression == BMPCompressionType.RGB) {
        foreach(y; 0..img.height)
        {
            //4 bits per pixel, so width/2 iterations
            foreach(x; 0..img.width/2)
            {
                ubyte[1] buf;
                istrm.fillArray(buf);
                const uint first = (buf[0] >> 4)*colormapEntrySize;
                const uint second = (buf[0] & 0x0f)*colormapEntrySize;
                
                if (!checkIndex(first, colormap) || !checkIndex(second, colormap)) {
                    return error(wrongIndexError);
                }
                img[x*2, img.height-y-1] = Color4f(ColorRGBA(colormap[first+2], colormap[first+1], colormap[first]));
                img[x*2 + 1, img.height-y-1] = Color4f(ColorRGBA(colormap[second+2], colormap[second+1], colormap[second]));
            }
            //for odd widths
            if (img.width & 1) {
                ubyte[1] buf;
                istrm.fillArray(buf);
                const uint index = (buf[0] >> 4)*colormapEntrySize;
                if (!checkIndex(index, colormap)) {
                    return error(wrongIndexError);
                }
                img[img.width-1, img.height-y-1] = Color4f(ColorRGBA(colormap[index+2], colormap[index+1], colormap[index]));
            }
        }
    } else if (bitsPerPixel == 8 && compression == BMPCompressionType.RGB) {
        foreach(y; 0..img.height)
        {
            foreach(x; 0..img.width)
            {
                ubyte[1] buf;
                istrm.fillArray(buf);
                const uint index = buf[0]*colormapEntrySize;
                if (!checkIndex(index, colormap)) {
                    return error(wrongIndexError);
                }
                img[x, img.height-y-1] = Color4f(ColorRGBA(colormap[index+2], colormap[index+1], colormap[index]));
            }
        }
    } else if (bitsPerPixel == 8 && compression == BMPCompressionType.RLE8) {
        int x, y;
        
        while(y < img.height) {
            ubyte value;
            if (!istrm.readLE(&value)) {
                break;
            }
            if (value == 0) {
                if (!istrm.readLE(&value) || value == 1) {
                    break;
                } else {
                    if (value == 0) {
                        x = 0;
                        y++;
                    } else if (value == 2) {
                        version(BMPDebug) {
                            writeln("in delta");
                        }
                        
                        ubyte xdelta, ydelta;
                        istrm.readLE(&xdelta);
                        istrm.readLE(&ydelta);
                        x += xdelta;
                        y += ydelta;
                    } else {
                        version(BMPDebug) {
                            writeln("in absolute mode");
                        }
                        foreach(i; 0..value) {
                            ubyte j;
                            istrm.readLE(&j);
                            const uint index = j*colormapEntrySize;
                            if (!checkIndex(index, colormap)) {
                                return error(wrongIndexError);
                            }
                            img[x++, img.height-y-1] = Color4f(ColorRGBA(colormap[index+2], colormap[index+1], colormap[index]));
                        }
                        if (value & 1) {
                            ubyte padding;
                            istrm.readLE(&padding);
                        }
                    }
                }
            } else {
                ubyte j;
                istrm.readLE(&j);
                const uint index = j*colormapEntrySize;
                if (!checkIndex(index, colormap)) {
                    return error(wrongIndexError);
                }
                foreach(i; 0..value) {
                    img[x++, img.height-y-1] = Color4f(ColorRGBA(colormap[index+2], colormap[index+1], colormap[index]));
                }
            }
        }
    } else if (bitsPerPixel == 16 || bitsPerPixel == 24 || bitsPerPixel == 32) {
        const bytesPerPixel = bitsPerPixel / 8;
        const bytesPerRow = ((bitsPerPixel*width+31)/32)*4; //round to multiple of 4
        const bytesPerLine = bytesPerPixel * width;
        const padding = bytesPerRow - bytesPerLine;
        
        if (bitsPerPixel == 24) {
            foreach(y; 0..img.height)
            {
                foreach(x; 0..img.width)
                {
                    ubyte[3] bgr;
                    istrm.fillArray(bgr);
                    img[x, img.height-y-1] = Color4f(ColorRGBA(bgr[2], bgr[1], bgr[0]));
                }

                istrm.seek(padding);
            }
        } else if (bitsPerPixel == 16) {
            foreach(y; 0..img.height)
            {
                foreach(x; 0..img.width)
                {
                    ubyte[2] bgr;
                    istrm.fillArray(bgr);
                    const uint p = bgr[0] | ((cast(uint)bgr[1]) << 8);
                    const ubyte r = applyMask(p, redMask, redShift, redScale);
                    const ubyte g = applyMask(p, greenMask, greenShift, greenScale);
                    const ubyte b = applyMask(p, blueMask, blueShift, blueScale);
                    
                    img[x, img.height-y-1] = Color4f(ColorRGBA(r,g,b));
                }

                istrm.seek(padding);
            }
        } else if (bitsPerPixel == 32) {
            foreach(y; 0..img.height)
            {
                foreach(x; 0..img.width)
                {
                    ubyte[4] bgr;
                    istrm.fillArray(bgr);
                    
                    const uint p = bgr[0] | ((cast(uint)bgr[1]) << 8) | ((cast(uint)bgr[2]) << 16) | ((cast(uint)bgr[3]) << 24);
                    
                    const ubyte r = applyMask(p, redMask, redShift, redScale);
                    const ubyte g = applyMask(p, greenMask, greenShift, greenScale);
                    const ubyte b = applyMask(p, blueMask, blueShift, blueScale);
                    
                    img[x, img.height-y-1] = Color4f(ColorRGBA(bgr[2], bgr[1], bgr[0], transparent ? applyMask(p, alphaMask, alphaShift, alphaScale) : 0xff));
                }

                istrm.seek(padding);
            }
        }
    } else {
        return error("loadBMP error: unknown or unsupported compression type / color depth combination");
    }

    if (colormap.length)
        Delete(colormap);
    
    return compound(img, "");
}
